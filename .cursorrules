# Car Audio Competition Platform - Cursor Rules

## Project Overview
This is a React/TypeScript car audio competition platform using Supabase as BaaS, with Stripe payments, AI integration, and comprehensive admin features.

## Tech Stack
- **Frontend**: React 18.3.1, TypeScript 5.5.3, Vite 6.3.5
- **Styling**: Tailwind CSS 3.4.1, Lucide React icons
- **Backend**: Supabase (PostgreSQL, Auth, Edge Functions)
- **Payments**: Stripe integration
- **AI**: OpenAI GPT integration
- **Email**: Postmark service

## Coding Standards

### TypeScript
- Always use TypeScript for new files
- Define interfaces for all props and data structures
- Use strict type checking
- Prefer `interface` over `type` for object definitions
- Use proper generic types for reusable components

### React
- Use functional components with hooks
- Prefer named exports over default exports
- Use React.memo() for performance optimization when needed
- Custom hooks should start with `use` prefix
- Keep components under 200 lines when possible

### File Structure
- Components in `src/components/`
- Pages in `src/pages/`
- Utilities in `src/utils/`
- Types in `src/types/`
- Hooks in `src/hooks/`
- Services in `src/services/`

### Naming Conventions
- **Components**: PascalCase (e.g., `UserProfile.tsx`)
- **Files**: kebab-case for utilities (e.g., `user-utils.ts`)
- **Variables**: camelCase
- **Constants**: UPPER_SNAKE_CASE
- **CSS Classes**: Tailwind utility classes

### Supabase Integration
- Use the existing `supabase` client from `src/lib/supabase`
- Always handle errors from Supabase operations
- Use Row Level Security (RLS) policies
- Prefer real-time subscriptions for live data
- Use TypeScript types for database schemas

### Security
- Never expose API keys in frontend code
- Use environment variables for sensitive data
- Implement proper authentication checks
- Follow RLS policies for database access
- Sanitize user inputs

### Performance
- Use lazy loading for routes
- Implement proper loading states
- Use React.memo() for expensive components
- Optimize images and assets
- Use Vite's code splitting features

## Code Style

### Imports
```typescript
// External libraries first
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';

// Internal imports
import { supabase } from '../lib/supabase';
import { UserProfile } from '../types/user';
import { formatDate } from '../utils/date-utils';
```

### Component Structure
```typescript
interface ComponentProps {
  title: string;
  isVisible: boolean;
  onClose: () => void;
}

export const Component: React.FC<ComponentProps> = ({ 
  title, 
  isVisible, 
  onClose 
}) => {
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // Effect logic here
  }, []);

  const handleAction = async () => {
    try {
      setLoading(true);
      // Async logic here
    } catch (error) {
      console.error('Error:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex items-center justify-center">
      {/* Component JSX */}
    </div>
  );
};
```

### Error Handling
- Always wrap async operations in try-catch
- Provide meaningful error messages
- Use loading states for async operations
- Handle edge cases gracefully

### CSS/Styling
- Use Tailwind CSS utility classes
- Follow mobile-first responsive design
- Use consistent spacing scale
- Prefer Tailwind over custom CSS
- Use semantic color names from theme

## Database Conventions
- Table names: snake_case
- Column names: snake_case
- Use UUIDs for primary keys
- Include created_at and updated_at timestamps
- Implement proper RLS policies

## API Integration
- Use proper TypeScript types for API responses
- Handle loading and error states
- Implement retry logic for critical operations
- Use proper HTTP status codes

## Testing
- Write unit tests for utility functions
- Test components with user interactions
- Mock external services in tests
- Use meaningful test descriptions

## Version Control
- Use the automatic version control system
- Never edit `src/utils/version.ts` manually
- Use semantic versioning for releases
- Write clear commit messages

## AI Assistant Guidelines
- Provide complete, working code examples
- Include proper TypeScript types
- Follow the established patterns in the codebase
- Consider performance implications
- Suggest improvements when relevant

## Common Patterns

### Supabase Queries
```typescript
const { data, error } = await supabase
  .from('table_name')
  .select('*')
  .eq('column', value);

if (error) {
  console.error('Database error:', error);
  return;
}
```

### Form Handling
```typescript
const [formData, setFormData] = useState<FormData>({});
const [loading, setLoading] = useState(false);

const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  setLoading(true);
  
  try {
    // Form submission logic
  } catch (error) {
    console.error('Form error:', error);
  } finally {
    setLoading(false);
  }
};
```

## Avoid
- Using `any` type
- Direct DOM manipulation
- Inline styles (use Tailwind)
- Hardcoded strings (use constants)
- Unhandled promises
- Memory leaks in useEffect

## Project-Specific Notes
- Mobile menu has been simplified to prevent memory leaks
- Version system is automated - don't manually edit version files
- Use the existing notification system instead of browser alerts
- Follow the established admin dashboard patterns
- Maintain consistency with existing UI components

## Performance Considerations
- The project has had memory issues with complex components
- Prefer simple, direct implementations over complex abstractions
- Use React.memo() judiciously
- Clean up subscriptions and event listeners

Remember: This is a production platform handling real users and payments. Prioritize security, performance, and user experience in all implementations.

## üö® CRITICAL PRODUCTION PROTOCOLS

### üî¥ ABSOLUTE PROHIBITIONS (NEVER DO)
- ‚ùå **NEVER reset or drop the database** - This is a production environment with real user data
- ‚ùå **NEVER disable RLS as a "quick fix"** - Security is non-negotiable
- ‚ùå **NEVER work without creating a backup first** - Always backup before significant changes
- ‚ùå **NEVER modify database security settings without explicit approval**
- ‚ùå **NEVER make changes that could break authentication**
- ‚ùå **NEVER work on multiple unrelated features simultaneously**
- ‚ùå **NEVER skip the mandatory QA process**
- ‚ùå **NEVER give multiple instructions at once** - User is new to development
- ‚ùå **NEVER continue without explicit user confirmation between steps**
- ‚ùå **NEVER use local database** - Always use remote Supabase database
- ‚ùå **NEVER provide multiple SQL files** - Only ONE SQL file per task

### ‚úÖ MANDATORY REQUIREMENTS (ALWAYS DO)
- ‚úÖ **ALWAYS create backup** before any significant changes (backup-[feature-name]-YYYY-MM-DD_HH-mm-ss)
- ‚úÖ **ALWAYS use step-by-step approach** with user confirmation at each stage
- ‚úÖ **ALWAYS provide only ONE SQL file** to be run in Supabase editor
- ‚úÖ **ALWAYS use remote database only** - Never suggest local database work
- ‚úÖ **ALWAYS explain what each step does and why it's needed**
- ‚úÖ **ALWAYS wait for "proceed" or "continue" before next step**
- ‚úÖ **ALWAYS test all changes thoroughly before presenting**
- ‚úÖ **ALWAYS consider impact on existing functionality**
- ‚úÖ **ALWAYS follow the automatic version control system**
- ‚úÖ **ALWAYS use the existing Supabase client from src/lib/supabase**

### üõ°Ô∏è DATABASE SAFETY PROTOCOLS
- **Remote Database Only**: All database work must be done on the remote Supabase instance
- **Single SQL File Rule**: Provide exactly ONE .sql file per task to run in Supabase editor
- **No Database Resets**: Never suggest dropping, truncating, or resetting database tables
- **RLS Protection**: Row Level Security policies must remain enabled and functional
- **Backup First**: Always create backup before any database schema changes
- **Step-by-Step Verification**: Each database change must be verified before proceeding

### üîÑ PRODUCTION WORKFLOW
1. **ACKNOWLEDGE PROTOCOLS**: Confirm understanding of all production rules
2. **CREATE BACKUP**: Follow naming convention backup-[feature-name]-YYYY-MM-DD_HH-mm-ss
3. **PLAN APPROACH**: Outline implementation strategy and get approval
4. **SINGLE SQL FILE**: Provide only ONE SQL file for database changes
5. **STEP-BY-STEP**: Execute with user confirmation at each stage
6. **TEST THOROUGHLY**: Complete QA before presenting results
7. **DOCUMENT CHANGES**: Update relevant documentation

### üìû COMMUNICATION PROTOCOL
```
STANDARD RESPONSE FORMAT:
1. Acknowledge the request
2. Confirm understanding of production constraints
3. Outline step-by-step plan
4. Request approval before proceeding
5. Provide only ONE SQL file if database changes needed
6. Wait for user confirmation before each step
7. Explain what each step does and why
```

### üö® EMERGENCY PROCEDURES
If something goes wrong:
1. **STOP** all work immediately
2. **ASSESS** the scope of the issue
3. **NOTIFY** the user of the problem
4. **RESTORE** from backup if necessary
5. **DOCUMENT** what went wrong and why

This is a production environment with real users and data. Every action must be deliberate, safe, and approved.

### üìù PROTOCOL MANAGEMENT & .cursorrules MAINTENANCE

#### üîÑ UPDATING .cursorrules FILE
- **Protocol Revision Authority**: AI agents MAY suggest updates to .cursorrules but ONLY with explicit user approval
- **No Autonomous Changes**: NEVER modify .cursorrules without user permission
- **Approval Required**: All protocol changes must be reviewed and approved before implementation
- **Documentation**: Explain WHY each protocol change is needed and what problem it solves

#### üö® WHEN TO RECOMMEND NEW RULES
AI agents SHOULD recommend new .cursorrules additions when they encounter:

1. **Recurring Issues**: Same problems happening multiple times across different tasks
2. **Security Gaps**: New security vulnerabilities or attack vectors discovered
3. **Performance Problems**: Patterns that consistently cause memory leaks or performance issues
4. **User Safety**: Situations that could lead to data loss or system instability
5. **Workflow Inefficiencies**: Processes that could be standardized for better consistency
6. **New Technology Integration**: When adding new tools or services that need specific protocols
7. **Production Incidents**: After any system failures or emergency situations

#### üìã PROTOCOL RECOMMENDATION FORMAT
```
üîß PROTOCOL RECOMMENDATION

Issue Identified: [DESCRIBE THE PROBLEM]
Frequency: [HOW OFTEN THIS OCCURS]
Risk Level: [CRITICAL/HIGH/MEDIUM/LOW]
Current Impact: [WHAT HAPPENS NOW]

Proposed Rule Addition:
‚ùå/‚úÖ [SPECIFIC RULE TEXT]

Rationale: [WHY THIS RULE IS NEEDED]
Benefits: [HOW THIS IMPROVES SAFETY/EFFICIENCY]
Implementation: [HOW TO ENFORCE THIS RULE]

Examples of when this would apply:
- [SCENARIO 1]
- [SCENARIO 2]

Request: May I add this rule to .cursorrules with your approval?
```

#### üéØ PROTOCOL REVIEW TRIGGERS
AI agents should proactively suggest protocol reviews when:
- **After Major Incidents**: Any system failure or data issues
- **New Feature Rollouts**: When adding significant new functionality
- **Security Updates**: After implementing security patches or fixes
- **Performance Optimizations**: When memory or speed issues are resolved
- **User Feedback**: When users report confusion or workflow problems
- **Technology Changes**: When upgrading major dependencies or tools

#### ‚úÖ APPROVED PROTOCOL CHANGES PROCESS
1. **Identify Need**: Recognize pattern requiring new rule
2. **Document Issue**: Provide clear examples and impact assessment
3. **Propose Solution**: Draft specific rule text and rationale
4. **Request Approval**: Get explicit user permission before changes
5. **Update File**: Modify .cursorrules with approved changes
6. **Communicate**: Notify about the update and why it was needed
7. **Monitor**: Watch for effectiveness of new rule

This ensures .cursorrules evolves safely while maintaining production stability.

## üß™ TESTING & DATA PROTOCOLS

### Mock Data Management
- **Testing Only**: Mock data is permitted ONLY during development and testing phases
- **QA Completion**: ALL mock data MUST be removed once QA is finalized
- **Production Clean**: Only real data and genuine statistics allowed on production server
- **Data Verification**: Always verify data authenticity before production deployment
- **Mock Data Markers**: Clearly mark all mock data with comments for easy identification

## üìã .cursorrules FILE GOVERNANCE

### Rule Modification Protocol
- **Approval Required**: ALL rule removals must be explicitly approved by James before implementation
- **No Autonomous Deletions**: NEVER remove rules without explicit permission
- **Presentation First**: The complete updated .cursorrules file MUST be presented and approved before being saved and activated
- **Change Documentation**: All rule changes must be logged in the version history

### File Management Standards
- **Always Present Before Save**: Show complete file content and get approval before activation
- **Mandatory Version Control**: ALWAYS update version log at bottom of file for ANY changes
- **Change Tracking**: Document what changed, when, and why
- **Line Count Accuracy**: Verify actual line count matches version history
- **Incremental Versioning**: Use semantic versioning for all .cursorrules updates

## üóÇÔ∏è PROJECT ORGANIZATION PROTOCOLS

### Folder Structure Management
- **Clean Organization**: Maintain clean, logical folder structure at all times
- **Daily Cleanup**: Run folder cleanup operations daily to remove temporary files
- **File Categorization**: Ensure all files are in appropriate directories
- **Remove Obsolete**: Delete outdated backups, temporary scripts, and unused files
- **Documentation Current**: Keep documentation files up-to-date and relevant

### Daily Maintenance Tasks
- Remove temporary files and scripts
- Clean up old backup directories (keep only recent essential backups)
- Organize loose files into appropriate directories
- Update documentation as needed
- Verify folder structure integrity

## üë• COMMUNICATION PROTOCOLS

### Personal Address Standards
- **James**: Erik will address the user as "James" in all communications
- **Erik**: James will address the AI assistant as "Erik"
- **Professional Courtesy**: Maintain respectful, professional communication tone
- **Clear Identification**: Always use names when beginning conversations or major task sections

## üßπ PROJECT ORGANIZATION & MAINTENANCE PROTOCOLS

### File & Folder Structure Management
- **Clean Organization**: Maintain clean, logical folder structure at all times
- **Daily Cleanup**: Remove temporary files, organize loose files into appropriate directories
- **Archive After QA**: After QA completion, move implementation files to appropriate archive locations
- **Catalog Maintenance**: Update BACKUP_CATALOG.md and SQL_CATALOG.md when files are moved
- **Archive Organization**: Use structured subdirectories (disabled-migrations, historical-development, implemented-features, emergency-fixes)
- **Clean Main Directory**: Keep only active, current files in main project directory

### Archive Workflow Protocol
1. **Complete Feature/Fix**: Implement and test functionality
2. **QA Completion**: Verify feature works correctly in production
3. **Archive Implementation**: Move setup/implementation files to appropriate archive subdirectory
4. **Update Catalogs**: Document file locations and purposes in catalog files
5. **Verify Cleanliness**: Ensure main directory remains organized and professional

### Production Safety for File Organization
- **Phase-Based Changes**: Implement file organization in phases to avoid production disruption
- **Path Analysis**: Before moving files, scan codebase for hardcoded references
- **Backwards Compatibility**: Maintain backwards compatibility during transitions
- **Test After Changes**: Verify all functionality after any file reorganization
- **Documentation Updates**: Update configuration files and documentation with new paths

This ensures .cursorrules evolves safely while maintaining production stability.

## üñºÔ∏è IMAGE & ASSET ORGANIZATION PROTOCOLS

### Mandatory Asset Structure
- **ALWAYS use organized asset paths**: `/assets/category/filename`
- **NEVER place images in root directories**: All images must be in `/public/assets/`
- **Required Categories**: Use only these three organized directories:
  - `/public/assets/logos/` - Brand logos and variants
  - `/public/assets/icons/` - PWA icons, mobile icons, app icons
  - `/public/assets/images/` - General images, credit card logos, photos

### File Naming Conventions
- **Logos**: `cae-logo-[variant].png` (e.g., `cae-logo-main.png`, `cae-logo-no-bg.png`)
- **Icons**: `[purpose]-[size].png` (e.g., `pwa-192x192.png`, `apple-touch-icon.png`)
- **Images**: `[descriptive-name].png` (e.g., `stripe-cc-logos.png`, `hero-banner.jpg`)
- **NO version numbers**: Use descriptive names instead of v1, v2, etc.
- **Use lowercase**: kebab-case naming (hyphens, not underscores or spaces)

### Asset Management Rules
- ‚úÖ **ALWAYS place new images** in appropriate `/public/assets/` subdirectory
- ‚úÖ **ALWAYS use descriptive filenames** that explain the image purpose
- ‚úÖ **ALWAYS reference organized paths** in components: `src="/assets/category/filename"`
- ‚ùå **NEVER place images** in root `public/` directory (except favicon.ico)
- ‚ùå **NEVER use scattered directories** like root `images/` folder
- ‚ùå **NEVER create custom image directories** outside the organized structure

### Production Asset Guidelines
- **Test new assets**: Verify images load correctly in both development and production
- **Optimize file sizes**: Compress images appropriately for web use
- **Use appropriate formats**: PNG for logos/icons, JPG for photos, SVG for vectors
- **Maintain backwards compatibility**: When updating assets, ensure all references are updated
- **Clean up duplicates**: Remove old/unused image files after successful migration

### Component Integration
- **Import organized paths**: Always reference `/assets/category/filename` in React components
- **Update all references**: When adding new images, update any related components
- **Test thoroughly**: Verify image loading in Header, Footer, and any custom components
- **Document changes**: Note any new assets in commit messages and documentation

This organized structure ensures professional asset management and scalable development.

## üöÄ PRODUCTION DEPLOYMENT PROTOCOLS

### Tech Stack Integration
- **Source Control**: GitHub repository (`car-audio-events`)
- **Hosting Platform**: Netlify with auto-deployment
- **Build System**: Vite (React/TypeScript)
- **Database**: Supabase (separate deployment process)

### Deployment Command Recognition
When users say these phrases, AI agents MUST execute the full deployment workflow:
- **Primary Commands**: `"Deploy to production"`, `"Push to production"`
- **Alternative Commands**: `"Deploy the changes"`, `"Initiate deployment process"`
- **Context Commands**: `"Push to GitHub and deploy to Netlify"`

### Mandatory 4-Phase Deployment Process
**Phase 1: Pre-Deployment Verification**
```bash
npm run build                    # ‚úÖ ALWAYS verify build first
dir dist\assets                  # ‚úÖ Check asset organization
```

**Phase 2: Git Operations**
```bash
git status                       # ‚úÖ Review all changes
git add [specific-files]         # ‚úÖ NEVER use git add .
git commit -m "feat: [desc]"     # ‚úÖ Semantic commit messages
git push origin main             # ‚úÖ Triggers auto-deployment
```

**Phase 3: Deployment Monitoring**
- Guide user to Netlify dashboard
- Monitor build logs for errors
- Verify deployment completion

**Phase 4: Production Verification**
- Test production site functionality
- Verify asset loading
- Confirm zero broken links

### Critical Deployment Safety Rules
- ‚úÖ **ALWAYS run `npm run build` first** - catches issues before deployment
- ‚úÖ **NEVER push without build verification** - prevents production failures
- ‚úÖ **Use specific `git add` commands** - avoid committing unwanted files
- ‚úÖ **Monitor Netlify build logs** - ensure successful deployment
- ‚úÖ **Verify production functionality** - confirm deployment success
- ‚ùå **NEVER skip any phase** - all 4 phases are mandatory
- ‚ùå **NEVER use `git add .`** - too risky for production

### GitHub ‚Üí Netlify Integration Flow
1. **Code Push**: Changes pushed to `main` branch
2. **Webhook Trigger**: Netlify receives automatic notification
3. **Cloud Build**: Netlify runs `npm run build` remotely
4. **Asset Processing**: All organized assets copied to CDN
5. **Live Deployment**: New version goes live automatically
6. **Rollback Available**: Previous versions maintained for instant rollback

### Deployment Documentation Reference
Full deployment guide available at: `documentation/deployment/PRODUCTION_DEPLOYMENT_GUIDE.md`

### Emergency Procedures
- **Build Fails**: Check TypeScript errors, verify `npm run build` locally
- **Missing Assets**: Verify organized asset paths and build output
- **Rollback**: Use Netlify dashboard to revert to previous deployment
- **Environment Issues**: Check Netlify environment variables

This process ensures zero-downtime deployments with full rollback capability.

## üìã .CURSORRULES VERSIONING PROTOCOLS

### Mandatory Versioning Requirements
- ‚úÖ **Version Increment**: ALWAYS increment version number for any .cursorrules modifications (Desending order) 
- ‚úÖ **Mandatory Changelog**: ALL rule changes must be logged in the version history at bottom of file
- ‚úÖ **Line Count Verification**: Verify actual file line count matches version history entry
- ‚úÖ **Complete Documentation**: Document what changed, why it changed, and what problem it solves
- ‚úÖ **Date Accuracy**: Use actual dates, never fabricate or use placeholder dates
- ‚úÖ **Minimal Changes**: When fixing errors, change ONLY what was requested, nothing else

### AI Agent Compliance Rules
- ‚ùå **NEVER remove existing rules** without explicit user approval
- ‚ùå **NEVER exceed requested scope** - when asked to fix one thing, change ONLY that thing
- ‚ùå **NEVER modify .cursorrules** without explicit permission first
- ‚úÖ **ALWAYS ask permission** before any .cursorrules modifications
- ‚úÖ **ALWAYS follow protocols exactly** to maintain user trust
- ‚úÖ **ALWAYS verify line counts** match version history entries

### Version History Standards
- **Accurate Dates**: All version entries must use real dates when changes occurred
- **Complete Change Log**: Document every addition, modification, or enhancement
- **Line Count Tracking**: Verify and update actual file line count for each version
- **Rationale Required**: Explain why each change was necessary and what problem it solved

---

## üìä VERSION HISTORY & CHANGELOG

### Version 1.3.0 - January 30, 2025
**Lines**: 467 total lines
**Major Project Completed**: Image Asset Reorganization & Deployment Protocol Implementation
**Changes Made**:
- Added comprehensive Production Deployment Protocols section
- Implemented mandatory 4-phase deployment process (Pre-Deployment, Git Operations, Monitoring, Verification)
- Established deployment command recognition for AI agents (`"Deploy to production"`, `"Push to production"`)
- Added GitHub ‚Üí Netlify integration flow documentation
- Implemented critical deployment safety rules and emergency procedures
- Added reference to detailed deployment guide: `documentation/deployment/PRODUCTION_DEPLOYMENT_GUIDE.md`
- Strengthened .cursorrules File Governance with mandatory version control requirements
- Enhanced File Management Standards with line count accuracy and incremental versioning
- Created comprehensive deployment documentation in `documentation/deployment/PRODUCTION_DEPLOYMENT_GUIDE.md`

**Production Deployments Today**:
- Image Asset Reorganization (Commit: 0715e78) - ‚úÖ Successful deployment to Netlify
- All organized assets verified in production: `/assets/logos/`, `/assets/icons/`, `/assets/images/`

**Rationale**: Codified the successful deployment process used in image reorganization project. Ensures all AI agents follow the same proven, safe deployment workflow with zero-downtime and full rollback capability. Enhanced versioning protocols to prevent incomplete changelog maintenance.

**Rationale**: Codified the successful image reorganization project into permanent protocols. Ensures all future image assets follow professional organization standards and prevents regression to scattered file structures.

**Rationale**: Enhanced production safety, improved project organization, established clear communication standards, and implemented proper governance for rule changes.

**Previous Version**: 1.0.0 (346 lines) - Initial comprehensive rules implementation 

### Version 1.1.0 - June 18, 2025
**Lines**: 435 total lines
**Changes Made**:
- Added Mock Data Management protocols for testing phases
- Implemented .cursorrules File Governance with approval requirements
- Added Project Organization Protocols with daily cleanup requirements
- Established Communication Protocols (James/Erik naming convention)
- Added comprehensive Version History tracking system

### Version 1.2.0 - June 18, 2025
**Lines**: 486 total lines
**Changes Made**:
- Added comprehensive Image & Asset Organization Protocols
- Implemented mandatory asset structure with organized directories
- Established file naming conventions for logos, icons, and images
- Added production asset guidelines and component integration rules
- Enforced organized path usage: `/assets/category/filename`